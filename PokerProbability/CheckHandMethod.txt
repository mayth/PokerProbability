http://oshiete.goo.ne.jp/qa/619584.html

フラッシュは省略するとして、
判定するのに、どういう中間データを作成すると簡単になるのかという事が全てなのですが、私からも１つ。

条件:　J、Q、K をそれぞれ 11、12、13 として、A を 1 と 14 の両方とする。

int work[15] を作成して、全て0で初期化する。
カード5枚の、マークを無視した数字部分を使って、work[数字]++ を5回実行する。
（Aのときだけ、work[1] と work[14] の両方に1を足す）

フォーカードであれば、work[1]～work[13]のどこかに4があり、フルハウスであれば、同様に3と2があるはずです。work[1]～work[13]をループで見ていき、4と3と2の数をカウントするだけでストレート以外は判定できます。

ストレートは、配列の連続した5箇所が全て1になっているはずなので、work[1]～work[14]をループで見ていけばすぐに判定できるでしょう。
ロイヤルストレートかどうかは、ストレートが満たされて、work[14]が1かどうかで判定できます。

--

いろいろやり方はあると思いますが、

やる前にまずソートするのがいいでしょう。
たとえば「7　3　1　7　Q」などのカードがあれば、
(数字順で)ソートしたら「1　3　7　7　Q」となります。
同じ数字があればかならず隣り合っています。
そこを
for(j=0; j<5-1; j++){
if(cards[j] == cards[j+1])onepair();
}
のようにループで調べることができます。

スリーカードも同様に調べられますが、
「ワンペア」→「スリーカード」の順で調べると
重複して数えてしまうので、
「フォーカード」→「スリーカード」→「ワンペア」
の順で調べるようにして、役該当カードは取り除く、
などの工夫が必要になるでしょう。

「ペア系判別ルーチン」「フラッシュ判別ルーチン」
「ストレート判別ルーチン」などを別個に作って、
一つ一つ通して、最後にストレートフラッシュなどの複合役を判別する、と言う流れになるかと思います。